//------------------------------------------------------------------------------
// [Definition of memory subregions (as subtypes of allocation)]
//
// We define a subregion as either (i) a field of an existing region
// (which itself is either a subregion or a normal allocation), or
// (ii) an array/pointer index of an existing region.
//
// In the second case, the index can be either a constant (which we
// record) or a variable. This corresponds to two different
// constructors, that in essence produce two distinct algebraic data
// types (plus a single one for referencing struct fields).
//
// When the index is unknown on the other hand (variable case), there
// is no index to record. In the string representation protocol as
// well as in code documentation, we will represent the unknown index
// with a star (*).
//
// As a final note, the need to create subregions stems from the fact
// that in C, we can refer to field addresses, and at a later point
// dereference them. This translates to a `getelementptr` instruction
// that computes the offset from a base pointer variable and assigns
// it to some other variable, which may then be supplied as the
// address operand to a `load`/`store` instruction. These two
// instructions may reside in different functions, so an
// intraprocedural matching would not work.
//
// This is an important difference with the Java Bytecode IR, where no
// such thing is possible and a single relation that connects two
// abstract objects (memory allocations) through some field is
// sufficient.
//------------------------------------------------------------------------------

alloc_subregion(Region) -> allocation(Region).
lang:entity(`alloc_subregion).

// Single constructor for field references

alloc_subregion:at_field[Alloc, Index] = Region ->
   allocation(Alloc), int[64](Index), alloc_subregion(Region).

// Constructor for constant array/pointer index

alloc_subregion:at_array_index[Alloc, Index] = Region ->
   allocation(Alloc), int[64](Index), alloc_subregion(Region).

// Constructor for unknown array/pointer index

alloc_subregion:at_any_array_index[Alloc] = Region ->
   allocation(Alloc), alloc_subregion(Region).

lang:constructor(`alloc_subregion:at_array_index).
lang:constructor(`alloc_subregion:at_any_array_index).
lang:constructor(`alloc_subregion:at_field).

// Define region base

alloc_subregion:base[Region] = Base ->
   alloc_subregion(Region), allocation(Base).

alloc_subregion:base[Region] = Base <-
   alloc_subregion:at_field[Base, _] = Region.

alloc_subregion:base[Region] = Base <-
   alloc_subregion:at_any_array_index[Base] = Region.

alloc_subregion:base[Region] = Base <-
   alloc_subregion:at_array_index[Base, _] = Region.

//------------------------------------------------------------------------
// [Maximum Subobject Depth]
//
// Note that pointer arithmetic and other C idioms may cause infinite
// recursion and creation of new subobjects. For instance, the
// instruction: `ptr = ptr + 1` when translated to a `getelementptr`
// instruction, it will create a new subobject relative to the one
// that `ptr` points to with some offset. However, this subobject will
// again flow to the base variable `ptr` triggering the creation of
// yet a new subobject. This creation of new subobjects will continue
// indefinitely.
//
// To avoid non-termination we introduce a bound to object
// depth. Hence, we do not create a new subobject when this bound is
// going to be exceeded.
//------------------------------------------------------------------------

field_sensitivity:max_depth[] = N ->
   int[64](N).

field_sensitivity:max_depth[] = 7.

//-----------------------------------------
// Define allocation depth recursively
//-----------------------------------------

allocation:depth[Alloc] = N ->
   allocation(Alloc), int[64](N).

allocation:depth[Alloc] = 0 <-
   basic_allocation(Alloc).

allocation:depth[Region] = N + 1 <-
   alloc_subregion:base[Region] = Base,
   allocation:depth[Base] = N.

//-----------------------------------------
// All subobject regions must have a depth
//-----------------------------------------

alloc_subregion(Alloc) -> allocation:depth[Alloc] = _.


// Allocation is entitled to create subobjects as maximum depth has
// not been reached

_may_expand_base_alloc(Alloc) <-
   field_sensitivity:max_depth[] = MaxDepth,
   allocation:depth[Alloc] = N,
   N < MaxDepth.


//-------------------------------------
// String Representation Protocol
//-------------------------------------

allocation:to_string[Region] = RegionStr <-
   alloc_subregion:at_array_index[Alloc, Index] = Region,
   allocation:to_string[Alloc] = AllocStr,
   int64:string:convert[Index] = IndexStr,
   RegionStr = AllocStr + "[" + IndexStr + "]".

allocation:to_string[Region] = RegionStr <-
   alloc_subregion:at_any_array_index[Alloc] = Region,
   allocation:to_string[Alloc] = AllocStr,
   RegionStr = AllocStr + "[*]".

allocation:to_string[Region] = RegionStr <-
   alloc_subregion:at_field[Alloc, Index] = Region,
   allocation:to_string[Alloc] = AllocStr,
   int64:string:convert[Index] = IndexStr,
   RegionStr = AllocStr + ".$" + IndexStr.


//------------------------------------------------------------------------------
// [Field Sensitive treatment of `getelementptr` instructions]
//
// We create subregions on the fly to act as destinations of
// instructions that may point to an allocation at some
// *offset*. Essentially, we create complex allocations paired with
// access paths in a demand-driven way, according to the given indices
// of some GEP instruction where an existing allocation is used as the
// base operand.

// Note that a subregion allocation created at some GEP instruction
// will be identified and used by other instructions too that happen
// to reference the same base allocation with the same offset.
//
// We filter null and other pseudo-allocations without depth by
// requiring that the base of the new region should itself have a
// depth.
//------------------------------------------------------------------------------


// Compute intermediate points to for `getelementptr` instruction up
// to some index

gep_points_to(Insn, Index, Alloc) ->
   getelementptr_instruction(Insn),
   int[64](Index),
   allocation(Alloc).

gep_points_to(Insn, 0, Alloc) <-
   !gep:vector_based(Insn),
   getelementptr_instruction:base[Insn] = Base,
   operand_points_to(Alloc, Base).

//----------------------------------------------------------
// For the first index of the GEP instruction
//----------------------------------------------------------

// First index is ignored when address operand points-to non-base
// object, regardless of type (constant or variable). In practice,
// most of the times the first index of any subsequent GEP
// instructions will be zero.

gep_points_to(Insn, 1, Alloc)
 <-
   gep_points_to(Insn, 0, Alloc),
   allocation:depth[Alloc] = N,
   N > 0.

// When address operand points-to base object, then we must record the
// index accordingly

alloc_subregion(Region)
 , alloc_subregion:at_array_index[Alloc, Index] = Region
 , gep_points_to(Insn, 1, Region)
 <-
   gep_points_to(Insn, 0, Alloc),
   _may_expand_base_alloc(Alloc), // redundant here (cause of 0 depth)
   allocation:depth[Alloc] = 0,
   getelementptr_instruction:index[Insn, 0] = IndexOp,
   operand:to_int[IndexOp] = Index.

alloc_subregion(Region)
 , alloc_subregion:at_any_array_index[Alloc] = Region
 , gep_points_to(Insn, 1, Region)
 <-
   gep_points_to(Insn, 0, Alloc),
   _may_expand_base_alloc(Alloc),
   allocation:depth[Alloc] = 0,
   getelementptr_instruction:index[Insn, 0] = IndexOp,
   !operand:to_int[IndexOp] = _.


//----------------------------------------------------------
// For the rest of the indices of the GEP instruction
//----------------------------------------------------------

// Case of unknown index

alloc_subregion(Region)
 , alloc_subregion:at_any_array_index[Alloc] = Region
 , gep_points_to(Insn, NextIndex, Region)
 <-
   gep_points_to(Insn, Index, Alloc),
   _may_expand_base_alloc(Alloc),
   getelementptr_instruction:interm_type[Insn, Index] = Type,
   array_type(Type),
   getelementptr_instruction:index[Insn, Index] = IndexOp,
   !operand:to_int[IndexOp] = _,
   instruction:next_index[Insn, Index] = NextIndex.


// Case of known constant index

alloc_subregion(Region)
 , alloc_subregion:at_array_index[Alloc, ConstantIndex] = Region
 , gep_points_to(Insn, NextIndex, Region)
 <-
   gep_points_to(Insn, Index, Alloc),
   _may_expand_base_alloc(Alloc),
   getelementptr_instruction:interm_type[Insn, Index] = Type,
   array_type(Type),
   getelementptr_instruction:index[Insn, Index] = IndexOp,
   operand:to_int[IndexOp] = ConstantIndex,
   instruction:next_index[Insn, Index] = NextIndex.


// Case of field access

alloc_subregion(Region)
 , alloc_subregion:at_field[Alloc, Field] = Region
 , gep_points_to(Insn, NextIndex, Region)
 <-
   gep_points_to(Insn, Index, Alloc),
   _may_expand_base_alloc(Alloc),
   getelementptr_instruction:interm_type[Insn, Index] = Type,
   struct_type(Type),
   getelementptr_instruction:index[Insn, Index] = IndexOp,
   operand:to_int[IndexOp] = Field,
   instruction:next_index[Insn, Index] = NextIndex.


// !! Generic fallback rule !! Whenever the maximum depth is reached
// the indices are therefore ignored and we switch to a
// field-insensitive approach beyond that, i.e., just propagating the
// object that was pointed to up to the previous index. In effect,
// when a memory region reaches its maximum depth, the points-to
// relation regarding this region is about any word contained in that
// region (that can be a pointer).

gep_points_to(Insn, NextIndex, Alloc)
 <-
   gep_points_to(Insn, Index, Alloc),
   allocation:depth[Alloc] = N,
   field_sensitivity:max_depth[] = N,
   instruction:next_index[Insn, Index] = NextIndex.


// The destination variable holds the allocation pointed by the last
// index of the associated `getelementptr` instruction

var_points_to(Alloc, ToVar) <-
   getelementptr_instruction:nindices[Insn] = Total,
   gep_points_to(Insn, Total, Alloc),
   instruction:to[Insn] = ToVar.


//------------------------------------------------------------------------
// [Implicit Pointer Aliases]
//
// In C, the expression `ptr[0]` and `*ptr` is the same. The 0 index
// is often omitted from some instructions, but we must ensure that
// such expressions are treated as aliases by the analysis and have
// the same points-to sets.
//------------------------------------------------------------------------

alloc_aliases(Alloc1, Alloc2) ->
   allocation(Alloc1), allocation(Alloc2).

// Reflexivity

alloc_aliases(Alloc, Alloc) <-
   allocation(Alloc).

// Transitivity

alloc_aliases(Alloc1, Alloc2) <-
   alloc_aliases(Alloc1, IntermAlloc),
   alloc_aliases(Alloc2, IntermAlloc).

// Symmetricitity

alloc_aliases(Alloc1, Alloc2) <-
   alloc_aliases(Alloc2, Alloc1).

// Aliases have the same points-to sets

ptr_points_to(Alloc, BaseAlloc1) <-
   ptr_points_to(Alloc, BaseAlloc2),
   alloc_aliases(BaseAlloc1, BaseAlloc2).


// A base allocation with zero index is an alias to base

alloc_aliases(Base, ZeroIndexBase) <-
   alloc_subregion:at_array_index[Base, 0] = ZeroIndexBase.


// TODO

// REVIEW !!! The following is incorrect as it does not comply to the
// GEP semantics. See `Why donâ€™t GEP x,0,0,1 and GEP x,1 alias?` from
// http://llvm.org/docs/GetElementPtr.html

// // Aliased bases will result in aliased subregions when extended by
// // the same field or index

// alloc_aliases(Alloc1, Alloc2) <-
//    alloc_aliases(Base1, Base2),
//    alloc_subregion:at_any_array_index[Base1] = Alloc1,
//    alloc_subregion:at_any_array_index[Base2] = Alloc2.

// alloc_aliases(Alloc1, Alloc2) <-
//    alloc_aliases(Base1, Base2),
//    alloc_subregion:at_array_index[Base1, Index] = Alloc1,
//    alloc_subregion:at_array_index[Base2, Index] = Alloc2.

// alloc_aliases(Alloc1, Alloc2) <-
//    alloc_aliases(Base1, Base2),
//    alloc_subregion:at_field[Base1, Field] = Alloc1,
//    alloc_subregion:at_field[Base2, Field] = Alloc2.

// // Create missing aliased allocations

// alloc_subregion(NewAlloc)
//  , alloc_subregion:at_field[Alloc1, Field] = NewAlloc
//  , allocation:depth[NewAlloc] = N1 + 1
//  <-
//    alloc_aliases(Alloc1, Alloc2),
//    allocation:depth[Alloc1] = N1,
//    allocation:depth[Alloc2] = N2,
//    N1 <= N2,
//    alloc_subregion:at_field[Alloc2, Field] = _.

// alloc_subregion(NewAlloc)
//  , alloc_subregion:at_array_index[Alloc1, Index] = NewAlloc
//  , allocation:depth[NewAlloc] = N1 + 1
//  <-
//    alloc_aliases(Alloc1, Alloc2),
//    allocation:depth[Alloc1] = N1,
//    allocation:depth[Alloc2] = N2,
//    N1 <= N2,
//    alloc_subregion:at_array_index[Alloc2, Index] = _.

// alloc_subregion(NewAlloc)
//  , alloc_subregion:at_any_array_index[Alloc1] = NewAlloc
//  , allocation:depth[NewAlloc] = N1 + 1
//  <-
//    alloc_aliases(Alloc1, Alloc2),
//    allocation:depth[Alloc1] = N1,
//    allocation:depth[Alloc2] = N2,
//    N1 <= N2,
//    alloc_subregion:at_any_array_index[Alloc2] = _.


//------------------------------------------------------------------------
// [Pattern Matching Star Expressions]
//
// By allowing star expressions in subregion allocations, we must
// ensure that when loading from some allocation we consider all other
// allocation that could potentially alias the former.  An allocation
// that contains a star expression (unknown index) is more generic
// than any allocation where the star is replaced by a specific
// constant index.
//
// For instance, when loading from an address that points-to an
// allocation such as `Base[1][*].$1[*][3]`, the possible dereferenced
// locations are not just those of its points-to set, but also those
// from `Base[1][c1].$1[c2][3]` for any c1, c2 constants (or even just
// one of them).
//
// To be able to reason about such relations between complex
// allocations, we define a relation (actually a partial-order)
// between allocations a1 and a2 that detects when a2 can pattern
// match a1 by replacing any or all of its star expressions with some
// constant indices.
//------------------------------------------------------------------------


// `StarredAlloc` is more generic than (ie, can pattern match)
// `Alloc`.

alloc_matches(Alloc, StarredAlloc) ->
   allocation(Alloc), allocation(StarredAlloc).

alloc_matches(Alloc, Alloc) <-
   allocation(Alloc).

alloc_matches(Alloc, StarredAlloc) <-
   alloc_matches(Base1, Base2),
   alloc_subregion:at_array_index[Base1, _] = Alloc,
   alloc_subregion:at_any_array_index[Base2] = StarredAlloc.

// TODO check with aliases
alloc_matches(Base1, StarredAlloc) <-
   alloc_matches(Base1, Base2),
   alloc_subregion:at_any_array_index[Base2] = StarredAlloc.

alloc_matches(Alloc1, Alloc2) <-
   alloc_matches(Base1, Base2),
   alloc_subregion:at_array_index[Base1, Index] = Alloc1,
   alloc_subregion:at_array_index[Base2, Index] = Alloc2.

alloc_matches(Alloc1, Alloc2) <-
   alloc_matches(Base1, Base2),
   alloc_subregion:at_field[Base1, Field] = Alloc1,
   alloc_subregion:at_field[Base2, Field] = Alloc2.


// When loading from an allocation we must also consider the more
// specific matching allocations and merge their points-to sets also.

var_points_to(Alloc, ToVar) <-
   reachable_instruction(Insn),
   instruction:to[Insn] = ToVar,
   load_instruction:address[Insn] = PtrOp,
   operand_points_to(OrigAlloc, PtrOp),
   alloc_matches(LessGenericAlloc, OrigAlloc),
   ptr_points_to(Alloc, LessGenericAlloc).

// We must also ensure that matching is considered in the opposite
// direction. We do that by extending the points-to set of an
// allocation by the points-to sets of all more generic allocations,
// ie, those that can pattern match it.

ptr_points_to(Alloc, OrigAlloc) <-
   ptr_points_to(Alloc, MoreGenericAlloc),
   alloc_matches(OrigAlloc, MoreGenericAlloc).


//-------------------------------------------------------------------
// [Memcpy instructions]
//
//  We must treat `memcpy` instructions in such a way as to ensure
//  that it may change the points-to set of any subregion of memory
//  that is being copied.
//-------------------------------------------------------------------

memcpy(Insn, To, From) ->
   instruction(Insn), allocation(To), allocation(From).

// Copy points-to set of copied objects

ptr_points_to(Alloc, To) <-
   memcpy(_, To, From),
   ptr_points_to(Alloc, From).

// Base case of `memcpy` call instructions

memcpy(CallInsn, ToAlloc, FromAlloc) <-
   function:name[Callee] = Name,
   ( string:like(Name, "@memcpy%")
   ; string:like(Name, "@llvm.memcpy%") ),
   callgraph:edge(Callee, CallInsn),
   call_instruction:arg[CallInsn, 0] = To,
   call_instruction:arg[CallInsn, 1] = From,
   operand_points_to(FromAlloc, From),
   operand_points_to(ToAlloc, To).


// Handle syntactic aliases. For instance `memcpy(to,from)` is
// equivalent to `memcpy(to, &from[0])`. Thus, we must propagate the
// memcpy handling to all aliased locations.

memcpy(Insn, AliasedTo, AliasedFrom) <-
   memcpy(Insn, ToAlloc, FromAlloc),
   alloc_aliases(AliasedTo, ToAlloc),
   alloc_aliases(AliasedFrom, FromAlloc).


// Recursive case for `memcpy` call instructions
//
// !! Note that in the following cases we have to create the
// destination subobject if it does not exist already, since we cannot
// afford to miss its points-to set because it may be copied to more
// generic objects that contain star expressions !!

alloc_subregion(DestSubobject)
 , alloc_subregion:at_field[DestObject, Field] = DestSubobject
 , memcpy(Insn, DestSubobject, SrcSubobject)
 <-
   memcpy(Insn, DestObject, SrcObject),
   _may_expand_base_alloc(DestObject),
   alloc_subregion:at_field[SrcObject, Field] = SrcSubobject.

alloc_subregion(DestSubobject)
 , alloc_subregion:at_array_index[DestObject, Index] = DestSubobject
 , memcpy(Insn, DestSubobject, SrcSubobject)
 <-
   memcpy(Insn, DestObject, SrcObject),
   _may_expand_base_alloc(DestObject),
   alloc_subregion:at_array_index[SrcObject, Index] = SrcSubobject.

alloc_subregion(DestSubobject)
 , alloc_subregion:at_any_array_index[DestObject] = DestSubobject
 , memcpy(Insn, DestSubobject, SrcSubobject)
 <-
   memcpy(Insn, DestObject, SrcObject),
   _may_expand_base_alloc(DestObject),
   alloc_subregion:at_any_array_index[SrcObject] = SrcSubobject.


//------------------------------------
// Region containment
//------------------------------------

region_contains(Outer, Inner) ->
   alloc_subregion(Inner), allocation(Outer).

region_contains(Outer, Inner) <-
   alloc_subregion:at_any_array_index[Outer] = Inner.

region_contains(Outer, Inner) <-
   alloc_subregion:at_array_index[Outer, _] = Inner.

region_contains(Outer, Inner) <-
   alloc_subregion:at_field[Outer, _] = Inner.

region_contains(Outer, Inner) <-
   region_contains(Interm, Inner),
   region_contains(Outer, Interm).

// Null cannot contain anything

null_location[] = Null ->
   !region_contains(Null, _).
